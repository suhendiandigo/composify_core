from collections.abc import Callable, Iterable, Iterator, Mapping, Sequence
from enum import Enum, auto
from typing import Any, overload

class MetadataSet:
    def __new__(items: Iterable[Any]): ...
    def __hash__(self): ...
    def __getitem__(self, key: type) -> Any: ...
    def get(self, key: type) -> Any | None: ...
    def issuperset(self, other: MetadataSet) -> bool: ...
    def issubset(self, other: MetadataSet) -> bool: ...

class Qualifiers:
    def __new__(items: Iterable[Any]): ...
    def __hash__(self): ...
    def __repr__(self): ...
    def qualify(self, attributes: MetadataSet) -> bool: ...

class RuleRegistry:
    def add_rule(self, rule: Rule) -> None: ...
    def add_rules(self, rules: Iterable[Rule]) -> None: ...
    def get_rules(self, type_info: type) -> Sequence[Rule]: ...

class TypeInfo:
    type_name: str
    type_module: str
    type_hash: int
    inner_type: type
    attributes: MetadataSet
    qualifiers: Qualifiers
    solve_parameter: SolveParameter

    def __new__(type_info: type, metadata: Sequence[Any]): ...
    @staticmethod
    def parse(any_type: Any) -> TypeInfo: ...
    def __hash__(self): ...
    def __repr__(self): ...

class Dependency:
    name: str
    typing: TypeInfo

    def __hash__(self): ...

class Dependencies:
    def __iter__(self) -> Iterator[Dependency]: ...
    def __hash__(self): ...

class Rule:
    function: Callable
    canonical_name: str
    output_type: TypeInfo
    dependencies: Dependencies
    priority: int
    is_async: bool

    def __new__(
        function: Callable,
        canonical_name: str,
        output_type: type,
        dependencies: Mapping[str, type],
        priority: int,
        is_async: bool,
    ): ...
    def __hash__(self): ...

class SolveSpecificity(Enum):
    """Determine the specificity of the solutions' result types:
    - (=) Exact: Allow only for exact type. No superclasses or subclasses are allowed.
    - (+) AllowSubclass: Allow for solutions resulting in subclasses.
    - (-) AllowSuperclass: Allow for solutions resulting in superclasses.
    """

    Exact = auto()
    AllowSubclass = auto()
    AllowSuperclass = auto()

class SolveCardinality(Enum):
    """Determine the number of solutions to match when solving for a specific type:
    - (*) Exhaustive: Solve for all possible solution including all permutations of dependencies.
    - (1) Single: Solve for the first possible solution respecting the priority of rules, ignoring the rest of the solutions.
    - (x) Exclusive: Solve for a single possible solution. Raises error if there are multiple solutions including permutations of dependencies.
    """

    Exhaustive = auto()
    Single = auto()
    Exclusive = auto()

class SolveParameter:
    def __new__(
        cls, specificity: SolveSpecificity, cardinality: SolveCardinality
    ): ...
    @property
    def specificity(self) -> SolveSpecificity: ...
    @property
    def cardinality(self) -> SolveCardinality: ...

class SolutionArg:
    @property
    def name(self) -> str: ...
    @property
    def solution(self) -> Solution: ...
    def __hash__(self): ...

class SolutionArgsCollection(Sequence[SolutionArg]):
    @overload
    def __new__(self): ...
    @overload
    def __new__(self, args: Mapping[str, Solution]): ...
    def __hash__(self): ...

class Solution:
    def __new__(self, rule: Rule, args: Mapping[str, Solution] | None): ...
    @property
    def rule(self) -> Rule: ...
    @property
    def args(self) -> SolutionArgsCollection: ...
    @property
    def function(self) -> Callable: ...
    @property
    def output_type(self) -> TypeInfo: ...
    @property
    def is_async(self) -> bool: ...
    def __hash__(self): ...

class Solver:
    def __new__(rules: RuleRegistry): ...
    def solve_for(self, type: Any) -> Sequence[Solution]: ...
